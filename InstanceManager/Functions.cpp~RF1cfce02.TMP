#define NOMINMAX
#include <map>
#include <regex>
#include <locale>
#include <codecvt>

#include "Functions.h"
#include "md5.h"
#include "AppLog.hpp"
#include "InstanceControl.h"

#include <openssl/bio.h>
#include <openssl/evp.h>
#include <fmt/format.h>
#include <cpr/cpr.h>
#include <tinyxml2.h>
#include <nlohmann/json.hpp>

#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Foundation.Collections.h>
#include <winrt/Windows.Management.Deployment.h>
#include <winrt/Windows.ApplicationModel.h>
#include <winrt/Windows.ApplicationModel.Core.h>
#include <winrt/Windows.ApplicationModel.Store.h>
#include <winrt/Windows.Storage.h>

#define USER_AGENT "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

namespace FS
{
    bool CopyDirectory(const std::filesystem::path& src, const std::filesystem::path& dst)
    {
        auto abs_src = std::filesystem::absolute(src);
        auto abs_dst = std::filesystem::absolute(dst);

        if (!std::filesystem::exists(abs_src) || !std::filesystem::is_directory(abs_src)) {
            std::cerr << "Source directory " << abs_src << " does not exist or is not a directory.\n";
            return false;
        }

        if (!std::filesystem::exists(abs_dst)) {
            std::filesystem::create_directories(abs_dst);
        }

        for (const auto& entry : std::filesystem::recursive_directory_iterator(abs_src)) {
            const auto& src_path = entry.path();
            auto dst_path = abs_dst / src_path.lexically_relative(abs_src);

            if (entry.is_directory()) {
                std::filesystem::create_directories(dst_path);
            }
            else if (entry.is_regular_file()) {
                try {
                    std::filesystem::copy_file(src_path, dst_path, std::filesystem::copy_options::overwrite_existing);
                }
                catch (const std::filesystem::filesystem_error& e) {
                    std::cerr << "Error copying file " << src_path << " to " << dst_path << ": " << e.what() << '\n';
                    return false;
                }
            }
            else {
                std::cerr << "Skipping non-regular file " << src_path << '\n';
            }
        }

        return true;
    }

    bool RemovePath(const std::filesystem::path& path_to_delete)
    {
        std::error_code ec;

        // Check if the path exists
        if (std::filesystem::exists(path_to_delete, ec))
        {
            try
            {
                if (std::filesystem::is_regular_file(path_to_delete))
                {
                    return std::filesystem::remove(path_to_delete, ec);
                }
                else if (std::filesystem::is_directory(path_to_delete))
                {
                    return std::filesystem::remove_all(path_to_delete, ec) > 0;
                }
                else
                {
                    std::cerr << "Error: Unsupported file type." << std::endl;
                    return false;
                }
            }
            catch (const std::filesystem::filesystem_error& e)
            {
                std::cerr << "Error: " << e.what() << std::endl;
                return false;
            }
        }
        else
        {
            // Path does not exist
            std::cerr << "Error: Path does not exist." << std::endl;
            return false;
        }
    }

    bool DecompressZip(const std::string& zipPath, const std::string& destination) {
        using namespace libzippp;

        ZipArchive zip(zipPath);
        if (!zip.open(ZipArchive::ReadOnly)) {
            AppLog::GetInstance().addLog("Failed to open zip archive: {}", zipPath);
            return false;
        }


        auto nbEntries = zip.getNbEntries();
        for (int i = 0; i < nbEntries; ++i) {
            ZipEntry entry = zip.getEntry(i);
            if (!entry.isNull()) {
                std::string outputPath = destination + "\\" + entry.getName();

                if (entry.isDirectory()) {
                    CreateDirectoryA(outputPath.c_str(), NULL);
                }
                else {
                    std::string content = entry.readAsText();
                    std::ofstream outputFile(outputPath, std::ios::binary);
                    if (outputFile) {
                        outputFile.write(content.c_str(), content.size());
                        outputFile.close();
                    }
                    else {
                        AppLog::GetInstance().addLog("Failed to write file: {}", outputPath);
                    }
                }
            }
        }

        zip.close();

        return true;
    }

    bool DecompressZipToFile(const std::string& zipPath, const std::string& destination) {
        using namespace libzippp;

        ZipArchive zip(zipPath);
        if (!zip.open(ZipArchive::ReadOnly)) {
            AppLog::GetInstance().addLog("Failed to open zip archive: {}", zipPath);
            return false;
        }

        auto nbEntries = zip.getNbEntries();

        if (nbEntries != 1) {
            AppLog::GetInstance().addLog("Zip archive must contain only one file: {}", zipPath);
            zip.close();
            return false;
        }

        ZipEntry entry = zip.getEntry(0);
        if (!entry.isNull() && !entry.isDirectory()) {
            std::string content = entry.readAsText();
            std::ofstream outputFile(destination, std::ios::binary);
            if (outputFile) {
                outputFile.write(content.c_str(), content.size());
                outputFile.close();
            }
            else {
                AppLog::GetInstance().addLog("Failed to write file: {}", destination);
                zip.close();
                return false;
            }
        }
        else {
            AppLog::GetInstance().addLog("Invalid zip entry: {}", zipPath);
            zip.close();
            return false;
        }

        zip.close();

        return true;
    }

    std::vector<std::string> FindFiles(const std::string& path, const std::string& substring) {
        std::vector<std::string> result;
        try {
            for (const auto& entry : std::filesystem::directory_iterator(path)) {
                if ((entry.is_regular_file() || entry.is_directory()) && entry.path().string().find(substring) != std::string::npos) {
                    result.push_back(entry.path().string());
                }
            }
        }
        catch (const std::filesystem::filesystem_error& e) {
            std::cerr << "Error: " << e.what() << std::endl;
        }

        return result;
    }

}

static const char* DISALLOWED_CHARS = "<>:\"/\\|?*\t\n\r ";

static int _MyResizeCallback(ImGuiInputTextCallbackData* data)
{
    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
    {
        std::string* my_str = (std::string*)data->UserData;
        IM_ASSERT(&my_str->front() == data->Buf);
        my_str->resize(data->BufSize - 1);
        data->Buf = &my_str->front();
    }
    return 0;
}

static int _WindowsNameFilter(ImGuiInputTextCallbackData* data)
{
    if (strchr(DISALLOWED_CHARS, (char)data->EventChar))
        return 1;

    // Check for underscore and replace with hyphen
    if (data->EventChar == '_')
    {
        data->EventChar = '-';
        return 0; // Allow the new character to pass through
    }

    return 0;
}

namespace ui
{
    bool InputTextWithHint(const char* label, const char* hint, std::string* my_str, ImGuiInputTextFlags flags)
    {
        IM_ASSERT((flags & (ImGuiInputTextFlags_CallbackResize | ImGuiInputTextFlags_CallbackCharFilter)) == 0);
        // Combine the resize callback and character filter callback
        auto combinedCallback = [](ImGuiInputTextCallbackData* data) -> int
        {
            if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
                return _MyResizeCallback(data);
            else if (data->EventFlag == ImGuiInputTextFlags_CallbackCharFilter)
                return _WindowsNameFilter(data);
            return 0;
        };

        if (my_str->empty()) {
            my_str->resize(1);
        }
        bool result = ImGui::InputTextWithHint(label, hint, &my_str->front(), my_str->size() + 1, flags | ImGuiInputTextFlags_CallbackResize | ImGuiInputTextFlags_CallbackCharFilter, combinedCallback, (void*)my_str);

        // Resize the string to its actual length after the InputTextWithHint call
        size_t actual_length = strlen(&my_str->front());
        my_str->resize(actual_length);

        return result;
    }


    bool ConditionalButton(const char* label, bool condition, ButtonStyle style)
    {
        bool beginDisabledCalled = false;

        if (!condition) {
            ImGui::BeginDisabled(true);
            beginDisabledCalled = true;
        }

        switch (style) {
        case ButtonStyle::Red:
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(82, 21, 21, 255));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, IM_COL32(92, 25, 25, 255));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive, IM_COL32(123, 33, 33, 255));
            break;
        case ButtonStyle::Green:
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(21, 82, 21, 255));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, IM_COL32(25, 92, 25, 255));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive, IM_COL32(33, 123, 33, 255));
            break;
        }

        bool pressed = ImGui::Button(label);

        ImGui::PopStyleColor(3);

        if (beginDisabledCalled) {
            ImGui::EndDisabled();
        }

        return pressed;
    }

    bool GreenButton(const char* label)
    {
        ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(21, 82, 21, 255));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, IM_COL32(25, 92, 25, 255));
        ImGui::PushStyleColor(ImGuiCol_ButtonActive, IM_COL32(33, 123, 33, 255));

        bool pressed = ImGui::Button(label);

        ImGui::PopStyleColor(3);

        return pressed;
    }

    bool RedButton(const char* label)
    {
        ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(82, 21, 21, 255));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, IM_COL32(92, 25, 25, 255));
        ImGui::PushStyleColor(ImGuiCol_ButtonActive, IM_COL32(123, 33, 33, 255));

        bool pressed = ImGui::Button(label);

        ImGui::PopStyleColor(3);

        return pressed;
    }

    void HelpMarker(const char* desc)
    {
        ImGui::TextDisabled("(?)");
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    }

    bool BeginSizedListBox(const char* label, float width_ratio, float height_ratio)
    {
        ImVec2 size = ImVec2(ImGui::GetContentRegionAvail().x * width_ratio, ImGui::GetContentRegionAvail().y * height_ratio);
        return ImGui::BeginListBox(label, size);
    }

    unsigned int ImVec4ToUint32(const ImVec4& color)
    {
        uint8_t r = static_cast<uint8_t>(color.x * 255.0f);
        uint8_t g = static_cast<uint8_t>(color.y * 255.0f);
        uint8_t b = static_cast<uint8_t>(color.z * 255.0f);
        uint8_t a = static_cast<uint8_t>(color.w * 255.0f);
        return (a << 24) | (b << 16) | (g << 8) | r;
    }
}


namespace Native
{
    std::string RunPowershellCommand(const std::string& command) {
        SECURITY_ATTRIBUTES security_attributes;
        ZeroMemory(&security_attributes, sizeof(security_attributes));
        security_attributes.nLength = sizeof(security_attributes);
        security_attributes.bInheritHandle = TRUE;

        HANDLE stdout_read = NULL;
        HANDLE stdout_write = NULL;

        if (!CreatePipe(&stdout_read, &stdout_write, &security_attributes, 0)) {
            std::cerr << "Failed to create pipe" << std::endl;
            return "";
        }

        STARTUPINFO startup_info;
        ZeroMemory(&startup_info, sizeof(startup_info));
        startup_info.cb = sizeof(startup_info);
        startup_info.hStdError = stdout_write;
        startup_info.hStdOutput = stdout_write;
        startup_info.dwFlags |= STARTF_USESTDHANDLES;

        PROCESS_INFORMATION process_info;
        ZeroMemory(&process_info, sizeof(process_info));

        std::string cmd_line = "powershell.exe -Command \"" + command + "\"";

        if (!CreateProcess(NULL, &cmd_line[0], NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &startup_info, &process_info)) {
            std::cerr << "Failed to create process" << std::endl;
            return "";
        }

        CloseHandle(stdout_write);

        constexpr size_t buffer_size = 4096;
        std::array<char, buffer_size> buffer;
        std::string output;

        DWORD bytes_read;
        while (ReadFile(stdout_read, buffer.data(), buffer_size, &bytes_read, NULL)) {
            output.append(buffer.data(), bytes_read);
        }

        CloseHandle(stdout_read);
        CloseHandle(process_info.hProcess);
        CloseHandle(process_info.hThread);

        return output;
    }

    winrt::com_ptr<IShellItemArray> CreateShellItemArrayFromProtocol(const winrt::hstring& protocolURI) {
        winrt::com_ptr<IShellItem> shellItem;
        HRESULT hr = SHCreateItemFromParsingName(protocolURI.c_str(), nullptr, IID_PPV_ARGS(&shellItem));
        if (FAILED(hr)) {
            return nullptr;
        }

        winrt::com_ptr<IShellItemArray> shellItemArray;
        hr = SHCreateShellItemArrayFromShellItem(shellItem.get(), IID_PPV_ARGS(&shellItemArray));
        if (FAILED(hr)) {
            return nullptr;
        }

        return shellItemArray;
    }

    DWORD LaunchUWPAppWithProtocol(const winrt::hstring& appID, const winrt::hstring& protocolURI) {
        winrt::com_ptr<IApplicationActivationManager> pAAM;
        HRESULT hr = CoCreateInstance(CLSID_ApplicationActivationManager, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARGS(&pAAM));
        if (FAILED(hr)) {
            AppLog::GetInstance().addLog("Failed to create IApplicationActivationManager instance. Error code: {}", hr);
            return 0;
        }

        auto shellItemArray = CreateShellItemArrayFromProtocol(protocolURI);
        if (!shellItemArray) {
            AppLog::GetInstance().addLog("Failed to create IShellItemArray from protocol URI.");
            return 0;
        }

        DWORD dwPID = 0;
        hr = pAAM->ActivateForProtocol(appID.c_str(), shellItemArray.get(), &dwPID);

        if (FAILED(hr)) {
            AppLog::GetInstance().addLog("Failed to activate UWP app. Error code: {}", hr);
            return 0;
        }

        return dwPID;
    }

    std::string GetCurrentUsername() {
        char username[UNLEN + 1];
        DWORD username_len = UNLEN + 1;

        if (GetUserName(username, &username_len)) {
            return std::string(username);
        }

        return "";
    }

    std::set<DWORD> GetInstancesOf(const char* exeName)
    {
        std::set<DWORD> pidSet;
        PROCESSENTRY32 entry;
        entry.dwSize = sizeof(PROCESSENTRY32);

        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

        if (Process32First(snapshot, &entry) == TRUE)
        {
            while (Process32Next(snapshot, &entry) == TRUE)
            {
                if (strcmp(entry.szExeFile, exeName) == 0)
                {
                    pidSet.insert(entry.th32ProcessID);
                }
            }
        }

        CloseHandle(snapshot);

        return pidSet;
    }


    std::string GetUserSID() {
        HANDLE hToken = NULL;
        DWORD dwSize = 0;
        TOKEN_USER* pTokenUser = NULL;
        LPTSTR StringSid = NULL;
        std::string sSid;

        auto Cleanup = [&]() {
            if (StringSid) {
                LocalFree(StringSid);
            }
            if (pTokenUser) {
                free(pTokenUser);
            }
            if (hToken) {
                CloseHandle(hToken);
            }
        };

        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
            Cleanup();
            return sSid; // Return empty 
        }

        GetTokenInformation(hToken, TokenUser, NULL, dwSize, &dwSize);
        pTokenUser = (TOKEN_USER*)malloc(dwSize);

        if (pTokenUser == NULL) {
            Cleanup();
            return sSid; // Return empty
        }

        if (!GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize)) {
            Cleanup();
            return sSid; // Return empty
        }

        if (!ConvertSidToStringSid(pTokenUser->User.Sid, &StringSid)) {
            Cleanup();
            return sSid; // Return empty
        }

        sSid = StringSid;

        std::transform(sSid.begin(), sSid.end(), sSid.begin(), ::tolower);

        Cleanup();

        return sSid;
    }

    std::string GetUserExperience()
    {
        const std::wstring userExperience = L"User Choice set via Windows User Experience {D18B6DD5-6124-4341-9318-804003BAFA0B}";
        const std::wstring str1 = L"User Choice set via Windows User Experience";

        wchar_t systemPath[MAX_PATH];
        SHGetFolderPathW(NULL, CSIDL_SYSTEMX86, NULL, 0, systemPath);
        std::wstring fullPath = std::wstring(systemPath) + L"\\Shell32.dll";

        std::ifstream file(fullPath, std::ios::binary);
        if (!file)
        {
            std::cerr << "Failed to open file." << std::endl;
            return StringUtils::WStrToStr(userExperience);
        }

        file.seekg(0, std::ios::end);
        size_t fileSize = file.tellg();
        file.seekg(0, std::ios::beg);
        std::vector<char> bytes(fileSize);
        file.read(bytes.data(), fileSize);
        file.close();

        std::wstring str2(reinterpret_cast<wchar_t*>(bytes.data()), fileSize / sizeof(wchar_t));

        size_t startIndex = str2.find(str1);
        if (startIndex != std::wstring::npos)
        {
            size_t endIndex = str2.find(L"}", startIndex);
            if (endIndex != std::wstring::npos)
            {
                return StringUtils::WStrToStr(str2.substr(startIndex, endIndex - startIndex + 1));
            }
        }

        return StringUtils::WStrToStr(userExperience);
    }

    std::string GetHexDatetime()
    {
        using namespace std::chrono;
        system_clock::time_point now = system_clock::now();
        time_t tt = system_clock::to_time_t(now);
        tm local_tm;
        localtime_s(&local_tm, &tt);

        local_tm.tm_sec = 0;

        tt = mktime(&local_tm);

        LONGLONG ll = Int32x32To64(tt, 10000000) + 116444736000000000;
        FILETIME ft;
        ft.dwLowDateTime = (DWORD)ll;
        ft.dwHighDateTime = ll >> 32;

        unsigned long long fileTime = ((unsigned long long)ft.dwHighDateTime << 32) + ft.dwLowDateTime;
        unsigned long num1 = fileTime >> 32;
        unsigned long num2 = fileTime & 0xFFFFFFFF;

        std::stringstream ss;
        ss << std::hex << std::setw(8) << std::setfill('0') << num1
            << std::setw(8) << std::setfill('0') << num2;

        return ss.str();
    }

    std::map<std::string, std::string> GetProgIDNames()
    {
        HKEY hKey;
        LONG lResult;
        std::map<std::string, std::string> ProgIdNames;

        // Open the registry key
        lResult = RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("SOFTWARE\\Classes"), 0, KEY_READ, &hKey);
        if (lResult != ERROR_SUCCESS) {
            // Handle error
            return ProgIdNames; // Return an empty map
        }

        DWORD dwIndex = 0; // Index of the subkey.
        DWORD dwSize = MAX_PATH; // Size of name buffer.
        TCHAR szSubKeyName[MAX_PATH]; // Buffer for subkey name.

        while (RegEnumKeyEx(hKey, dwIndex, szSubKeyName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
            HKEY hSubKey;
            // Open the subkey
            if (RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS) {
                HKEY hApplicationKey, hShellOpenKey;
                // Check for the presence of "Application" subkey
                if (RegOpenKeyEx(hSubKey, TEXT("Application"), 0, KEY_READ, &hApplicationKey) == ERROR_SUCCESS) {
                    // Check for the presence of "shell\open" subkey
                    if (RegOpenKeyEx(hSubKey, TEXT("shell\\open"), 0, KEY_READ, &hShellOpenKey) == ERROR_SUCCESS) {
                        // Check for the presence of "PackageId" value
                        TCHAR szPackageId[MAX_PATH];
                        DWORD dwBufferSize = sizeof(szPackageId);
                        if (RegQueryValueEx(hShellOpenKey, TEXT("PackageId"), NULL, NULL, (LPBYTE)szPackageId, &dwBufferSize) == ERROR_SUCCESS) {
                            std::string key = szPackageId;
                            if (ProgIdNames.find(key) == ProgIdNames.end()) {
                                std::string value = szSubKeyName;
                                ProgIdNames[key] = value.substr(value.find_last_of('\\') + 1);
                            }
                        }
                        RegCloseKey(hShellOpenKey);
                    }
                    RegCloseKey(hApplicationKey);
                }
                RegCloseKey(hSubKey);
            }

            // Reset variables for next iteration
            dwSize = MAX_PATH;
            dwIndex++;
        }

        // Close the main registry key
        RegCloseKey(hKey);

        return ProgIdNames;
    }

    PVOID GetPebAddress(HANDLE ProcessHandle)
    {
        _NtQueryInformationProcess NtQueryInformationProcess =
            (_NtQueryInformationProcess)GetProcAddress(
                GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");
        PROCESS_BASIC_INFORMATION pbi;

        NtQueryInformationProcess(ProcessHandle, 0, &pbi, sizeof(pbi), NULL);

        return pbi.PebBaseAddress;
    }

    std::string GetCommandlineArguments(DWORD pid)
    {
        HANDLE processHandle;
        PVOID pebAddress;
        PVOID rtlUserProcParamsAddress;
        UNICODE_STRING commandLine;
        WCHAR* commandLineContents;

        if ((processHandle = OpenProcess(
            PROCESS_QUERY_INFORMATION | /* required for NtQueryInformationProcess */
            PROCESS_VM_READ, /* required for ReadProcessMemory */
            FALSE, pid)) == 0)
        {
            return std::string();
        }

        pebAddress = GetPebAddress(processHandle);

        if (!ReadProcessMemory(processHandle,
            &(((_PEB*)pebAddress)->ProcessParameters),
            &rtlUserProcParamsAddress,
            sizeof(PVOID), NULL))
        {
            return std::string();
        }

        if (!ReadProcessMemory(processHandle,
            &(((_RTL_USER_PROCESS_PARAMETERS*)rtlUserProcParamsAddress)->CommandLine),
            &commandLine, sizeof(commandLine), NULL))
        {
            return std::string();
        }

        commandLineContents = (WCHAR*)malloc(commandLine.Length);

        if (!ReadProcessMemory(processHandle, commandLine.Buffer,
            commandLineContents, commandLine.Length, NULL))
        {
            return std::string();
        }

        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
        std::string command_line_str = converter.to_bytes(commandLineContents);
        CloseHandle(processHandle);
        free(commandLineContents);

        return command_line_str;
    }


    bool OpenInExplorer(const std::string& path, bool isFile) {
        std::string cmd = isFile ? "/select," + path : path;
        HINSTANCE result = ShellExecute(0, "open", "explorer.exe", cmd.c_str(), 0, SW_SHOW);
        return (INT_PTR)result > 32;
    }

    bool SetProcessAffinity(DWORD processID, DWORD requestedCores)
    {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        DWORD numberOfCores = sysInfo.dwNumberOfProcessors;

        if (requestedCores <= 0 || requestedCores > numberOfCores) {
            std::cerr << "Invalid number of cores requested." << std::endl;
            return false;
        }

        DWORD_PTR mask = 0;
        for (DWORD i = 0; i < requestedCores; i++) {
            mask |= (1 << i);
        }

        HANDLE hProcess = OpenProcess(PROCESS_SET_INFORMATION, FALSE, processID);
        if (hProcess == NULL) {
            std::cerr << "Failed to open process. Error code: " << GetLastError() << std::endl;
            return false;
        }

        if (SetProcessAffinityMask(hProcess, mask) == 0) {
            std::cerr << "Failed to set process affinity. Error code: " << GetLastError() << std::endl;
            CloseHandle(hProcess);
            return false;
        }

        CloseHandle(hProcess);
        return true;
    }

    bool IsReadableMemory(const MEMORY_BASIC_INFORMATION& mbi) {
        return mbi.State == MEM_COMMIT &&
            !(mbi.Protect & PAGE_NOACCESS) &&
            !(mbi.Protect & PAGE_GUARD);
    }

    bool IsProcessRunning(DWORD targetPid, const CHAR* expectedName)
    {
        DWORD aProcesses[1024], cbNeeded, cProcesses;

        if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
            return false;
        }

        cProcesses = cbNeeded / sizeof(DWORD);

        for (unsigned int i = 0; i < cProcesses; i++) {
            if (aProcesses[i] != targetPid) {
                continue;
            }

            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, targetPid);
            if (NULL == hProcess) {
                return false;
            }

            CHAR szProcessName[MAX_PATH] = "<unknown>";
            HMODULE hMod;

            if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
                GetModuleBaseNameA(hProcess, hMod, szProcessName, sizeof(szProcessName) / sizeof(CHAR));
            }

            CloseHandle(hProcess);

            if (strcmp(szProcessName, expectedName) == 0) {
                return true;
            }
            else {
                return false;
            }
        }


        return false;
    }

    BOOL TerminateProcessByName(const char* processName)
    {
        DWORD processes[1024], numProcesses;
        unsigned int i;

        if (!EnumProcesses(processes, sizeof(processes), &numProcesses)) {
            return FALSE;
        }

        numProcesses /= sizeof(DWORD);

        for (i = 0; i < numProcesses; i++) {
            if (processes[i] != 0) {
                HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_TERMINATE, FALSE, processes[i]);
                if (hProcess) {
                    char processNameInList[MAX_PATH];

                    if (GetModuleBaseName(hProcess, 0, processNameInList, sizeof(processNameInList) / sizeof(char))) {
                        if (strcmp(processNameInList, processName) == 0) {
                            TerminateProcess(hProcess, 0);
                        }
                    }
                    CloseHandle(hProcess);
                }
            }
        }

        return TRUE;
    }

    std::string SearchEntireProcessMemory(HANDLE pHandle, const unsigned char* pattern, size_t patternSize, ExtractFunction extractFunction) {
        uintptr_t address = 0;
        MEMORY_BASIC_INFORMATION mbi = {};

        while (VirtualQueryEx(pHandle, (void*)address, &mbi, sizeof(mbi))) {
            if (IsReadableMemory(mbi)) {
                std::vector<unsigned char> buffer(mbi.RegionSize);

                if (ReadProcessMemory(pHandle, (void*)address, buffer.data(), mbi.RegionSize, nullptr)) {
                    uintptr_t offset = Utils::BoyerMooreHorspool(pattern, patternSize, buffer.data(), mbi.RegionSize);
                    if (offset != 0) {
                        std::string value = extractFunction(buffer.data() + offset + patternSize, mbi.RegionSize - offset - patternSize);
                        if (!value.empty()) {
                            return value;
                        }
                    }
                }
            }

            // Move to the next memory region
            address += mbi.RegionSize;
        }

        return "";
    }
}

namespace StringUtils
{
    bool ContainsOnly(const std::string& s, char c) {
        return s.find_first_not_of(c) == std::string::npos;
    }

    bool CopyToClipboard(const std::string& data) {
        if (!OpenClipboard(nullptr)) {
            return false;
        }

        EmptyClipboard();

        // +1 for the null terminator
        size_t size = (data.size() + 1) * sizeof(char);
        HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, size);
        if (!hMem) {
            CloseClipboard();
            return false;
        }

        // Copy the string to the allocated memory
        char* pMem = static_cast<char*>(GlobalLock(hMem));
        if (pMem) {
            std::copy(data.begin(), data.end(), pMem);
            pMem[data.size()] = '\0'; // null terminator
            GlobalUnlock(hMem);
        }
        else {
            GlobalFree(hMem);
            CloseClipboard();
            return false;
        }

        SetClipboardData(CF_TEXT, hMem);
        if (GetLastError() != ERROR_SUCCESS) {
            GlobalFree(hMem);
            CloseClipboard();
            return false;
        }

        CloseClipboard();

        // Do not free the hMem after SetClipboardData, as the system will take ownership of it.
        return true;
    }

    std::string WStrToStr(const std::wstring& wstr)
    {
        int numBytes = WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, NULL, 0, NULL, NULL);
        std::vector<char> buffer(numBytes);
        WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, buffer.data(), numBytes, NULL, NULL);
        return std::string(buffer.data());
    }
}

namespace Roblox
{
    void NukeInstane(const std::string name, const std::string path)
    {
        std::string cmd = "Get-AppxPackage -Name \"" + name + "\" | Remove-AppxPackage";
        Native::RunPowershellCommand(cmd);

        std::thread([path]() {
            FS::RemovePath(path);
        }).detach();
    }

    std::unordered_map<std::string, Roblox::Instance> ProcessRobloxPackages() {
        std::unordered_map<std::string, Roblox::Instance> instancesMap;

        winrt::Windows::Management::Deployment::PackageManager packageManager;

        try {
            for (const auto& package : packageManager.FindPackages()) {
                // Check Publisher ID
                std::wstring publisherID = package.Id().PublisherId().c_str();
                if (publisherID == L"55nm5eh3cm0pr") {
                    Roblox::Instance instance;

                    instance.PackageID = winrt::to_string(package.Id().FullName().c_str());
                    instance.PackageFamilyName = winrt::to_string(package.Id().FamilyName().c_str());
                    instance.Version = std::to_string(package.Id().Version().Major) + "." +
                        std::to_string(package.Id().Version().Minor) + "." +
                        std::to_string(package.Id().Version().Revision) + "." +
                        std::to_string(package.Id().Version().Build);
                    if (package.InstalledLocation()) {
                        instance.InstallLocation = winrt::to_string(package.InstalledLocation().Path().c_str());
                    }
                    else {
                        instance.InstallLocation = "Not Available";
                    }

                    // Getting AppListEntry information
                    auto appListEntries = package.GetAppListEntriesAsync().get();
                    for (const auto& appListEntry : appListEntries) {
                        std::string fullName = winrt::to_string(package.Id().FullName().c_str());
                        size_t underscorePosition = fullName.find('_');
                        if (underscorePosition != std::string::npos) {
                            instance.Name = fullName.substr(0, underscorePosition);
                        }
                        else {
                            instance.Name = fullName;
                        }

                        instance.AppID = winrt::to_string(appListEntry.AppUserModelId().c_str());
                    }

                    // Extract the desired key using regex
                    std::string fullName = winrt::to_string(package.Id().Name().c_str());
                    std::regex r(R"(([^.]+)$)");  // Match any substring that doesn't contain a dot, at the end of the string
                    std::smatch match;
                    if (std::regex_search(fullName, match, r) && match.size() > 1) {
                        std::string key = match.str(1);  // First capturing group
                        instancesMap[key] = instance;
                    }
                }
            }
        }
        catch (const winrt::hresult_error& ex) {
            std::wcerr << L"WinRT error: " << ex.message().c_str() << std::endl;
        }

        return instancesMap;
    }

    ModifyXMLError ModifySettings(std::string filePath, int newGraphicsQualityValue, float newMasterVolumeValue, int newSavedQualityValue)
    {
        tinyxml2::XMLDocument doc;
        tinyxml2::XMLError eResult = doc.LoadFile(filePath.c_str());
        if (eResult != tinyxml2::XML_SUCCESS) {
            return ModifyXMLError::LoadError;
        }

        tinyxml2::XMLElement* itemElement = doc.FirstChildElement("roblox")->FirstChildElement("Item");
        if (!itemElement || std::string(itemElement->Attribute("class")) != "UserGameSettings") {
            return ModifyXMLError::NotFound;
        }

        tinyxml2::XMLElement* propertiesElement = itemElement->FirstChildElement("Properties");
        if (!propertiesElement) {
            return ModifyXMLError::NotFound;
        }

        tinyxml2::XMLElement* graphicsQualityElement = propertiesElement->FirstChildElement("int");
        while (graphicsQualityElement && std::string(graphicsQualityElement->Attribute("name")) != "GraphicsQualityLevel") {
            graphicsQualityElement = graphicsQualityElement->NextSiblingElement("int");
        }
        if (graphicsQualityElement) {
            graphicsQualityElement->SetText(newGraphicsQualityValue);
        }

        tinyxml2::XMLElement* masterVolumeElement = propertiesElement->FirstChildElement("float");
        while (masterVolumeElement && std::string(masterVolumeElement->Attribute("name")) != "MasterVolume") {
            masterVolumeElement = masterVolumeElement->NextSiblingElement("float");
        }
        if (masterVolumeElement) {
            masterVolumeElement->SetText(newMasterVolumeValue);
        }

        tinyxml2::XMLElement* savedQualityElement = propertiesElement->FirstChildElement("token");
        while (savedQualityElement && std::string(savedQualityElement->Attribute("name")) != "SavedQualityLevel") {
            savedQualityElement = savedQualityElement->NextSiblingElement("token");
        }
        if (savedQualityElement) {
            savedQualityElement->SetText(newSavedQualityValue);
        }

        eResult = doc.SaveFile(filePath.c_str());
        if (eResult != tinyxml2::XML_SUCCESS) {
            return ModifyXMLError::SaveError;
        }

        return ModifyXMLError::Success;
    }

    std::string EnterCode(std::string code, std::string cookie)
    {
        nlohmann::json j;
        j["code"] = code;

        cpr::Response r = cpr::Post(
            cpr::Url{ "https://apis.roblox.com/auth-token-service/v1/login/enterCode" },
            cpr::Header{ {"Content-Type", "application/json"}, { "Referer", "https://www.roblox.com/" }, { "User-Agent", USER_AGENT }, { "x-csrf-token", GetCSRF(cookie) }, { "Accept", "application/json" }, { "Origin", "https://www.roblox.com" } },
            cpr::Cookies{ {".ROBLOSECURITY", cookie} },
            cpr::Body{ j.dump() }
        );

        return r.text;
    }

    std::string ValidateCode(std::string code, std::string cookie)
    {
        nlohmann::json j;
        j["code"] = code;

        cpr::Response r = cpr::Post(
            cpr::Url{ "https://apis.roblox.com/auth-token-service/v1/login/validateCode" },
            cpr::Header{ {"Content-Type", "application/json"}, { "Referer", "https://www.roblox.com/" }, { "User-Agent", USER_AGENT }, { "x-csrf-token", GetCSRF(cookie) }, { "Accept", "application/json" }, { "Origin", "https://www.roblox.com" } },
            cpr::Cookies{ {".ROBLOSECURITY", cookie} },
            cpr::Body{ j.dump() }
        );

        return r.text;
    }

    std::string GetCSRF(std::string cookie)
    {
        cpr::Response r = cpr::Post(
            cpr::Url{ "https://auth.roblox.com/v1/authentication-ticket" },
            cpr::Header{ {"Content-Type", "application/json"}, { "Referer", "https://www.roblox.com/" } },
            cpr::Cookies{ {".ROBLOSECURITY", cookie} }
        );

        return r.header["x-csrf-token"];
    }

    std::string ExtractCode(const unsigned char* dataStart, size_t dataSize) {
        std::string code;
        const unsigned char* dataEnd = dataStart + dataSize;
        while (dataStart != dataEnd && *dataStart != 0x22) {
            code += static_cast<char>(*dataStart);
            dataStart++;
        }
        return code;
    }

    std::string FindCodeValue(HANDLE pHandle, const std::string& name) {

        std::string windowName = std::string("Roblox ") + name;
        HWND hWnd = FindWindow(NULL, windowName.c_str());

        SetForegroundWindow(hWnd);

        // First pattern: key=???????-????-????-????-????????????&code=
        auto pattern1 = Utils::ParsePattern("6B 65 79 3D ?? ?? ?? ?? ?? ?? ?? ?? 2D ?? ?? ?? ?? 2D ?? ?? ?? ?? 2D ?? ?? ?? ?? 2D ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 26 63 6F 64 65 3D");
        std::string codeValue = Native::SearchEntireProcessMemory(pHandle, pattern1.data(), pattern1.size(), Roblox::ExtractCode);

        if (!codeValue.empty()) return codeValue;

        // Second pattern: "\"code\":\""
        unsigned char pattern2[] = { 0x22, 0x63, 0x6F, 0x64, 0x65, 0x22, 0x3A, 0x22 };
        size_t patternSize2 = sizeof(pattern2) / sizeof(unsigned char);
        codeValue = Native::SearchEntireProcessMemory(pHandle, pattern2, patternSize2, Roblox::ExtractCode);

        return codeValue;
    }

    std::vector<std::string> GetNewInstances(const std::vector<std::string>& old_instances) {
        std::vector<std::string> new_instances = g_InstanceControl.GetInstanceNames();
        std::vector<std::string> result;

        // Check if an instance in new_instances is not present in old_instances
        for (const auto& new_instance : new_instances) {
            bool found = false;
            for (const auto& old_instance : old_instances) {
                if (new_instance == old_instance) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                result.push_back(new_instance);
            }
        }

        return result;
    }
}

namespace Utils
{
    std::vector<unsigned char> ParsePattern(const std::string& patternString) {
        std::vector<unsigned char> pattern;
        size_t start = 0;
        size_t end = patternString.find(' ');

        while (end != std::string::npos) {
            std::string byteString = patternString.substr(start, end - start);
            if (byteString == "??") {
                pattern.push_back('?');
            }
            else {
                unsigned long byteValue = std::strtol(byteString.c_str(), nullptr, 16);
                pattern.push_back(static_cast<unsigned char>(byteValue));
            }
            start = end + 1;
            end = patternString.find(' ', start);
        }

        // Handle the last token in the string (after the last space)
        std::string byteString = patternString.substr(start, end);
        if (byteString == "??") {
            pattern.push_back('?');
        }
        else {
            unsigned long byteValue = std::strtol(byteString.c_str(), nullptr, 16);
            pattern.push_back(static_cast<unsigned char>(byteValue));
        }

        return pattern;
    }

    bool SaveToFile(const std::string& file_path, const std::vector<char8_t>& buffer)
    {
        std::ofstream ofs(file_path, std::ios::out | std::ios::binary);

        if (!ofs.is_open())
            return false;

        ofs.write(reinterpret_cast<const char*>(buffer.data()), buffer.size());
        ofs.close();

        return true;
    }

    uintptr_t BoyerMooreHorspool(const unsigned char* signature, size_t signatureSize, const unsigned char* data, size_t dataSize)
    {
        size_t maxShift = signatureSize;
        size_t maxIndex = signatureSize - 1;
        size_t wildCardIndex = 0;
        for (size_t i = 0; i < maxIndex; i++) {
            if (signature[i] == '?') {
                maxShift = maxIndex - i;
                wildCardIndex = i;
            }
        }

        size_t shiftTable[256];
        for (size_t i = 0; i <= 255; i++) {
            shiftTable[i] = maxShift;
        }

        for (size_t i = wildCardIndex + 1; i < maxIndex - 1; i++) {
            shiftTable[signature[i]] = maxIndex - i;
        }

        for (size_t currentIndex = 0; currentIndex < dataSize - signatureSize;) {
            for (size_t sigIndex = maxIndex; sigIndex >= 0; sigIndex--) {
                if (data[currentIndex + sigIndex] != signature[sigIndex] && signature[sigIndex] != '?') {
                    currentIndex += shiftTable[data[currentIndex + maxIndex]];
                    break;
                }
                else if (sigIndex == 0) {
                    return currentIndex;
                }
            }
        }

        return 0;
    }

    void DownloadAndSave(const std::string& url, const std::string& localFileName) {
        /*
        std::vector<char8_t> buffer;
        Request req(url);
        req.initalize();
        req.download_file<char8_t>(buffer);
        Utils::SaveToFile(localFileName, buffer);
        */
        std::ofstream out(localFileName, std::ios::binary);
        cpr::Response r = cpr::Download(out, cpr::Url{ url });
        out.close();
    }

    void DecompressZip(const std::string& zipFile, const std::string& destination) {
        if (std::filesystem::exists(destination)) {
            std::filesystem::remove(destination);
        }
        FS::DecompressZipToFile(zipFile, destination);
    }

    void CopyFileToDestination(const std::string& source, const std::string& destination) {
        if (std::filesystem::exists(destination)) {
            std::filesystem::remove(destination);
        }
        std::filesystem::copy_file(source, destination);
    }

    std::string ModifyAppxManifest(std::string inputXML, std::string name)
    {
        tinyxml2::XMLDocument doc;
        doc.Parse(inputXML.c_str());

        // <Identity> element's Name attribute
        tinyxml2::XMLElement* identityElement = doc.FirstChildElement("Package")->FirstChildElement("Identity");
        if (identityElement) {
            const char* nameValue = identityElement->Attribute("Name");
            if (nameValue) {
                std::string newNameValue = std::string(nameValue) + "." + name;
                identityElement->SetAttribute("Name", newNameValue.c_str());
            }
        }

        // <uap:VisualElements> tag
        tinyxml2::XMLElement* visualElement = doc.FirstChildElement("Package")->FirstChildElement("Applications")->FirstChildElement("Application")->FirstChildElement("uap:VisualElements");
        if (visualElement) {
            const char* displayNameValue = visualElement->Attribute("DisplayName");
            if (displayNameValue) {
                std::string newDisplayNameValue = std::string(displayNameValue) + " " + name;
                visualElement->SetAttribute("DisplayName", newDisplayNameValue.c_str());
            }
        }

        // <uap:DefaultTile> tag
        tinyxml2::XMLElement* defaultTile = visualElement->FirstChildElement("uap:DefaultTile");
        if (defaultTile) {
            const char* shortNameValue = defaultTile->Attribute("ShortName");
            if (shortNameValue) {
                std::string newShortNameValue = std::string(shortNameValue) + " " + name;
                defaultTile->SetAttribute("ShortName", newShortNameValue.c_str());
            }
        }

        // <DisplayName> tag under <Properties>
        tinyxml2::XMLElement* propertiesDisplayName = doc.FirstChildElement("Package")->FirstChildElement("Properties")->FirstChildElement("DisplayName");
        if (propertiesDisplayName) {
            const char* displayNameText = propertiesDisplayName->GetText();
            if (displayNameText) {
                std::string newDisplayNameText = std::string(displayNameText) + " " + name;
                propertiesDisplayName->SetText(newDisplayNameText.c_str());
            }
        }

        tinyxml2::XMLPrinter printer;
        doc.Print(&printer);
        return printer.CStr();
    }

    struct FileContent {
        std::string data;  // This will hold the actual content
        int64_t read_len = 0;  // This will keep track of the amount of data read
    };

    bool write_data(const std::string& data, intptr_t userdata) {
        FileContent* content = reinterpret_cast<FileContent*>(userdata);
        content->data += data;
        content->read_len += data.size();
        return true;
    }


    void WriteAppxManifest(const std::string& url, const std::string& localPath, const std::string& name) {
        cpr::Session session;
        session.SetUrl(cpr::Url{url});

        FileContent file_content;

        cpr::Response result = session.Download(cpr::WriteCallback{write_data, reinterpret_cast<intptr_t>(&file_content)});

        std::string downloaded_str = file_content.data;

        if (!name.empty()) {
            downloaded_str = Utils::ModifyAppxManifest(downloaded_str, name);
        }

        std::ofstream outfile(localPath, std::ofstream::out | std::ofstream::trunc);
        outfile.write(downloaded_str.c_str(), downloaded_str.size());
        outfile.flush();
    }

    void UpdatePackage(const std::string& baseFolder, const std::string& instanceName) {
        // For Windows10Universal.zip
        std::thread win10t([&, baseFolder]() {
            DownloadAndSave("https://raw.githubusercontent.com/Sightem/Instance-Manager/master/Template/Windows10Universal.zip", "Windows10Universal.zip");
            DecompressZip("Windows10Universal.zip", baseFolder + "\\Windows10Universal.exe");
        });

        // For CrashHandler.exe
        std::thread crasht([&, baseFolder]() {
            DownloadAndSave("https://raw.githubusercontent.com/Sightem/Instance-Manager/master/Template/Assets/CrashHandler.exe", "CrashHandler.exe");
            CopyFileToDestination("CrashHandler.exe", baseFolder + "\\Assets\\CrashHandler.exe");
        });

        // For AppxManifest.xml
        std::thread appxt([&, baseFolder, instanceName]() {
            WriteAppxManifest("https://raw.githubusercontent.com/Sightem/Instance-Manager/master/Template/AppxManifest.xml", baseFolder + "\\AppxManifest.xml");
        });

        win10t.join();

        AppLog::GetInstance().addLog("Updated Windows10Universal");

        crasht.join();

        AppLog::GetInstance().addLog("Updated CrashHandler");

        appxt.join();

        AppLog::GetInstance().addLog("Updated AppxManifest");
    }

    bool SaveScreenshotAsPng(const char* filename)
    {
        HDC screenDC = GetDC(NULL);
        HDC memoryDC = CreateCompatibleDC(screenDC);

        // Get the dimensions of the entire virtual screen (all monitors)
        int screenX = GetSystemMetrics(SM_XVIRTUALSCREEN);
        int screenY = GetSystemMetrics(SM_YVIRTUALSCREEN);
        int screenWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);

        HBITMAP bitmap = CreateCompatibleBitmap(screenDC, screenWidth, screenHeight);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(memoryDC, bitmap);

        // Copy the entire virtual screen
        BitBlt(memoryDC, 0, 0, screenWidth, screenHeight, screenDC, screenX, screenY, SRCCOPY);

        BITMAPINFOHEADER bi;
        bi.biSize = sizeof(BITMAPINFOHEADER);
        bi.biWidth = screenWidth;
        bi.biHeight = -screenHeight; // Top-down orientation
        bi.biPlanes = 1;
        bi.biBitCount = 24;
        bi.biCompression = BI_RGB;
        bi.biSizeImage = 0;
        bi.biXPelsPerMeter = 0;
        bi.biYPelsPerMeter = 0;
        bi.biClrUsed = 0;
        bi.biClrImportant = 0;

        DWORD dwBmpSize = ((screenWidth * bi.biBitCount + 31) / 32) * 4 * screenHeight;
        std::vector<BYTE> lpBitmapBits(dwBmpSize);
        GetDIBits(screenDC, bitmap, 0, screenHeight, lpBitmapBits.data(), (BITMAPINFO*)&bi, DIB_RGB_COLORS);

        // Convert BGR to RGB
        for (size_t i = 0; i < dwBmpSize; i += 3)
        {
            std::swap(lpBitmapBits[i], lpBitmapBits[i + 2]);
        }

        SelectObject(memoryDC, oldBitmap);
        DeleteObject(bitmap);
        DeleteDC(memoryDC);
        ReleaseDC(NULL, screenDC);

        int result = stbi_write_png(filename, screenWidth, screenHeight, 3, lpBitmapBits.data(), screenWidth * 3);
        return result != 0;
    }

}
